<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
    overscroll-behavior: none; /* Disable bounce overflow effect. */
  }
  body {
    margin: 0;
  }
</style>
<script>
  class Thing {
    constructor(x, y) {
      this.t0 = performance.now();
      this.x0 = x; // initial position (px)
      this.y0 = y; // initial position (px)
      this.r0 = Math.random() * 2 * Math.PI; // initial rotation (rad)
      this.direction = Math.random() * 2 * Math.PI; // (rad)
      this.velocity = Math.random() * (0.6 - 0.3) + 0.3; // (px/ms)
      this.rotationalVelocity = Math.random() * 0.05 - (0.05 / 2); // (rad/ms)
      this.width = 25;
      this.height = 25;
      this.color = '#'+Math.random().toString(16).substr(-6);
      this.element = document.createElement('div');
      this.element.style.width = this.width + 'px';
      this.element.style.height = this.height + 'px';
      this.element.style.background = this.color;
      this.element.style.position = 'absolute';
      this.element.style.willChange = 'transform';
    }

    update(currentTime) {
      var time = currentTime - this.t0;

      var maxTime = 1000;
      if (time > maxTime) {
        this.remove();
        return false;
      }

      var x = this.x0 + this.velocity * Math.cos(this.direction) * time;
      var y = this.y0 + this.velocity * Math.sin(this.direction) * time;
      var trans = `translate(${x - this.width / 2}px, ${y - this.height / 2}px)`;
      var rotate = `rotate(${this.r0 + this.rotationalVelocity * time}rad)`;
      var scale = `scale(${Math.max((maxTime - time) / maxTime, 0)})`;
      this.element.style.transform = `${trans} ${rotate} ${scale}`;
      this.element.style.opacity = Math.max((maxTime - time) / maxTime, 0.01);
      if (!this.element.parentElement)
        document.documentElement.appendChild(this.element);
      return true;
    }

    remove() {
      if (this.element.parentElement)
        this.element.parentElement.removeChild(this.element);
    }
  }

  var things = [];
  function spawnThings(x, y) {
    var addMultiplier = 3; // Add multiple things per spawn.
    for (var i = 0; i < addMultiplier; i++)
      things.push(new Thing(x, y));
  }

  var framerate = 0;
  var lastFrameTime = performance.now();
  function updateThings(time) {
    // Use an exponential moving average of the last 3 frames for the framerate.
    framerate = framerate * 2 / 3 + (time - lastFrameTime) / 3;
    lastFrameTime = time;

    // Cull a percentage when frames are missed.
    var missedFrames = Math.max(Math.floor(framerate / 16.67), 0);
    var cullPercent = Math.min(Math.pow(missedFrames, 2) / 100, 0.1);
    var cullCount = Math.floor(things.length * cullPercent);
    for (var cull = 0; cull < cullCount; cull++) {
      var cullIndex = Math.floor(Math.random() * things.length);
      things[cullIndex].remove();
      things.splice(cullIndex, 1);
    }

    for (var idx in things) {
      if (!things[idx].update(time))
        things.splice(idx, 1);
    }
    requestAnimationFrame(updateThings);
  }
  requestAnimationFrame(updateThings);

  document.documentElement.addEventListener('touchstart', function(e) {
    for (var idx = 0; idx < e.touches.length; idx++)
      spawnThings(e.touches[idx].clientX, e.touches[idx].clientY);
  });
  document.documentElement.addEventListener('touchmove', function(e) {
    for (var idx = 0; idx < e.touches.length; idx++)
      spawnThings(e.touches[idx].clientX, e.touches[idx].clientY);
  });
  document.documentElement.addEventListener('mousedown', function(e) {
    spawnThings(e.clientX, e.clientY);
  });
  document.documentElement.addEventListener('mousemove', function(e) {
    spawnThings(e.clientX, e.clientY);
  });

  var attemptedFullscreen = false;
  document.documentElement.addEventListener('click', function(e) {
    if (!attemptedFullscreen)
      document.documentElement.webkitRequestFullscreen();
    attemptedFullscreen = true;
  });
</script>
